---
import type { Book } from '../types/book';

interface Props {
  books: Book[];
}

const { books } = Astro.props;

// Extraer valores únicos para los filtros
const allAuthors = [...new Set(books.flatMap(book => book.author))].sort();
const allPublishers = [...new Set(books.flatMap(book => book.publishers))].sort();
---

<div class="filter-bar" id="filter-bar">
  <div class="filter-group">
    <label for="search-input" class="filter-label">Buscar</label>
    <input
      type="text"
      id="search-input"
      class="filter-input"
      placeholder="Buscar por título..."
      autocomplete="off"
      aria-label="Buscar libros por título o subtítulo"
      aria-describedby="search-description"
    />
    <span id="search-description" class="sr-only">Busca libros escribiendo parte del título o subtítulo</span>
  </div>

  <div class="filter-group">
    <label for="status-filter" class="filter-label">Estado</label>
    <select id="status-filter" class="filter-select" aria-label="Filtrar por estado de lectura">
      <option value="all">Todos</option>
      <option value="read">Leídos</option>
      <option value="unread">Pendientes</option>
    </select>
  </div>

  <div class="filter-group">
    <label for="author-filter" class="filter-label">Autor</label>
    <select id="author-filter" class="filter-select" aria-label="Filtrar por autor">
      <option value="all">Todos los autores</option>
      {allAuthors.map(author => (
        <option value={author}>{author}</option>
      ))}
    </select>
  </div>

  <div class="filter-group">
    <label for="publisher-filter" class="filter-label">Editorial</label>
    <select id="publisher-filter" class="filter-select" aria-label="Filtrar por editorial">
      <option value="all">Todas las editoriales</option>
      {allPublishers.map(publisher => (
        <option value={publisher}>{publisher}</option>
      ))}
    </select>
  </div>

  <div class="filter-group">
    <label for="sort-select" class="filter-label">Ordenar</label>
    <select id="sort-select" class="filter-select" aria-label="Ordenar libros">
      <option value="default">Orden original</option>
      <option value="title-asc">Título (A-Z)</option>
      <option value="title-desc">Título (Z-A)</option>
      <option value="author-asc">Autor (A-Z)</option>
      <option value="author-desc">Autor (Z-A)</option>
      <option value="read-date-asc">Fecha lectura (antiguos primero)</option>
      <option value="read-date-desc">Fecha lectura (recientes primero)</option>
    </select>
  </div>

  <button id="clear-filters" class="clear-button" type="button" aria-label="Limpiar todos los filtros y mostrar todos los libros">Limpiar filtros</button>
</div>

<div class="filter-results" id="filter-results" role="status" aria-live="polite" aria-atomic="true">
  <span id="results-count"></span>
</div>

<script is:inline>
  (function() {
    'use strict';

    // Función para inicializar cuando el DOM esté listo
    function initFilters() {
      // Elementos del DOM
      const searchInput = document.getElementById('search-input');
      const statusFilter = document.getElementById('status-filter');
      const authorFilter = document.getElementById('author-filter');
      const publisherFilter = document.getElementById('publisher-filter');
      const sortSelect = document.getElementById('sort-select');
      const clearButton = document.getElementById('clear-filters');
      const resultsCount = document.getElementById('results-count');

      if (!searchInput || !statusFilter || !authorFilter || !publisherFilter || !sortSelect || !clearButton) {
        console.error('Elementos de filtro no encontrados');
        setTimeout(initFilters, 100);
        return;
      }

      // Función para actualizar la URL sin recargar
      function updateURL(params) {
        try {
          const url = new URL(window.location.href);
          Object.entries(params).forEach(([key, value]) => {
            if (value && value !== 'all' && value !== 'default') {
              url.searchParams.set(key, value);
            } else {
              url.searchParams.delete(key);
            }
          });
          window.history.replaceState({}, '', url);
        } catch (e) {
          console.error('Error actualizando URL:', e);
        }
      }

      // Función para leer parámetros de la URL
      function getURLParams() {
        try {
          const params = new URLSearchParams(window.location.search);
          return {
            search: params.get('search') || '',
            status: params.get('status') || 'all',
            author: params.get('author') || 'all',
            publisher: params.get('publisher') || 'all',
            sort: params.get('sort') || 'default',
          };
        } catch (e) {
          return { search: '', status: 'all', author: 'all', publisher: 'all', sort: 'default' };
        }
      }

      // Función para obtener libros que coinciden con filtros (excluyendo un filtro específico)
      function getMatchingBooks(excludeFilter) {
        const bookCards = document.querySelectorAll('.book-card');
        const searchTerm = excludeFilter !== 'search' ? searchInput.value.toLowerCase().trim() : '';
        const status = excludeFilter !== 'status' ? statusFilter.value : 'all';
        const author = excludeFilter !== 'author' ? authorFilter.value : 'all';
        const publisher = excludeFilter !== 'publisher' ? publisherFilter.value : 'all';

        const matchingBooks = [];

        bookCards.forEach((card) => {
          const cardTitle = card.getAttribute('data-book-title') || '';
          const cardSubtitle = card.getAttribute('data-book-subtitle') || '';
          const cardAuthors = JSON.parse(card.getAttribute('data-book-authors') || '[]');
          const cardPublishers = JSON.parse(card.getAttribute('data-book-publishers') || '[]');
          const cardRead = card.getAttribute('data-book-read') === 'true';

          const matchesSearch = !searchTerm || 
            cardTitle.includes(searchTerm) ||
            cardSubtitle.includes(searchTerm);
          const matchesStatus = status === 'all' ||
            (status === 'read' && cardRead) ||
            (status === 'unread' && !cardRead);
          const matchesAuthor = author === 'all' ||
            cardAuthors.includes(author);
          const matchesPublisher = publisher === 'all' ||
            cardPublishers.includes(publisher);

          if (matchesSearch && matchesStatus && matchesAuthor && matchesPublisher) {
            matchingBooks.push({
              authors: cardAuthors,
              publishers: cardPublishers
            });
          }
        });

        return matchingBooks;
      }

      // Función para actualizar opciones de un select
      function updateSelectOptions(selectElement, options, currentValue) {
        const isAuthorFilter = selectElement.id === 'author-filter';
        const defaultText = isAuthorFilter ? 'Todos los autores' : 'Todas las editoriales';
        
        // Guardar el valor actual antes de limpiar
        const previousValue = selectElement.value;
        
        // Limpiar y reconstruir opciones
        selectElement.innerHTML = '<option value="all">' + defaultText + '</option>';
        
        options.forEach(option => {
          const optionElement = document.createElement('option');
          optionElement.value = option;
          optionElement.textContent = option;
          selectElement.appendChild(optionElement);
        });

        // Mantener la selección actual si está disponible, o resetear a 'all'
        // Usar currentValue primero, luego previousValue como fallback
        const valueToUse = currentValue || previousValue;
        if (valueToUse && valueToUse !== 'all' && options.includes(valueToUse)) {
          selectElement.value = valueToUse;
        } else {
          selectElement.value = 'all';
        }
      }

      // Función para actualizar los dropdowns basándose en los filtros activos
      function updateDropdowns(changedFilter) {
        // Para autores: siempre excluir el filtro de autor para mostrar todas las opciones disponibles
        // Esto considera: search, status, y publisher (pero no author)
        const booksForAuthors = getMatchingBooks('author');
        const availableAuthors = [...new Set(booksForAuthors.flatMap(book => book.authors))].sort();

        // Para editoriales: siempre excluir el filtro de editorial para mostrar todas las opciones disponibles
        // Esto considera: search, status, y author (pero no publisher)
        const booksForPublishers = getMatchingBooks('publisher');
        const availablePublishers = [...new Set(booksForPublishers.flatMap(book => book.publishers))].sort();

        // Actualizar dropdown de autores (siempre, para reflejar los filtros actuales)
        const currentAuthor = authorFilter.value;
        updateSelectOptions(authorFilter, availableAuthors, currentAuthor);

        // Actualizar dropdown de editoriales (siempre, para reflejar los filtros actuales)
        const currentPublisher = publisherFilter.value;
        updateSelectOptions(publisherFilter, availablePublishers, currentPublisher);
      }

      // Función de filtrado
      function filterBooks(changedFilter) {
        // Obtener referencias a las tarjetas de libros (cada vez por si cambian)
        const bookCards = document.querySelectorAll('.book-card');
        
        if (bookCards.length === 0) {
          console.warn('No se encontraron tarjetas de libros, reintentando...');
          setTimeout(() => filterBooks(changedFilter), 100);
          return;
        }

        const searchTerm = searchInput.value.toLowerCase().trim();
        const status = statusFilter.value;
        const author = authorFilter.value;
        const publisher = publisherFilter.value;
        const sort = sortSelect.value;

        // Actualizar URL
        updateURL({ search: searchTerm, status, author, publisher, sort });

        // Actualizar dropdowns dinámicamente ANTES de filtrar
        updateDropdowns(changedFilter);

        // Re-obtener valores después de actualizar dropdowns (por si se reseteó)
        const finalAuthor = authorFilter.value;
        const finalPublisher = publisherFilter.value;

        let visibleCount = 0;

        bookCards.forEach((card) => {
          // Leer datos directamente de los data attributes
          const cardTitle = card.getAttribute('data-book-title') || '';
          const cardSubtitle = card.getAttribute('data-book-subtitle') || '';
          const cardAuthors = JSON.parse(card.getAttribute('data-book-authors') || '[]');
          const cardPublishers = JSON.parse(card.getAttribute('data-book-publishers') || '[]');
          const cardRead = card.getAttribute('data-book-read') === 'true';

          // Filtro de búsqueda (título y subtítulo)
          const matchesSearch = !searchTerm || 
            cardTitle.includes(searchTerm) ||
            cardSubtitle.includes(searchTerm);

          // Filtro de estado
          const matchesStatus = status === 'all' ||
            (status === 'read' && cardRead) ||
            (status === 'unread' && !cardRead);

          // Filtro de autor
          const matchesAuthor = finalAuthor === 'all' ||
            cardAuthors.includes(finalAuthor);

          // Filtro de editorial
          const matchesPublisher = finalPublisher === 'all' ||
            cardPublishers.includes(finalPublisher);

          // Mostrar u ocultar según todos los filtros con animación
          if (matchesSearch && matchesStatus && matchesAuthor && matchesPublisher) {
            if (card.classList.contains('hiding') || card.style.display === 'none') {
              // Mostrar con animación
              card.style.display = '';
              card.classList.remove('hiding');
              card.classList.add('showing');
              // Remover clase showing después de la animación
              setTimeout(() => {
                card.classList.remove('showing');
              }, 400);
            }
            visibleCount++;
          } else {
            // Ocultar con animación
            if (!card.classList.contains('hiding')) {
              card.classList.add('hiding');
              setTimeout(() => {
                if (card.classList.contains('hiding')) {
                  card.style.display = 'none';
                  card.classList.remove('hiding');
                }
              }, 300);
            }
          }
        });

        // Actualizar contador de resultados
        if (resultsCount) {
          if (visibleCount === bookCards.length) {
            resultsCount.textContent = '';
          } else {
            resultsCount.textContent = `${visibleCount} de ${bookCards.length} libros`;
          }
        }

        // Aplicar ordenamiento después del filtrado
        sortBooks();
      }

      // Función de ordenamiento
      function sortBooks() {
        const bookGrid = document.querySelector('.book-grid');
        if (!bookGrid || !sortSelect) return;

        const sortValue = sortSelect.value;
        
        // Obtener todas las tarjetas (visibles y ocultas)
        const allCards = Array.from(bookGrid.querySelectorAll('.book-card'));
        
        // Separar visibles y ocultas usando getComputedStyle para mayor confiabilidad
        const visibleCards = allCards.filter(card => {
          const computedStyle = window.getComputedStyle(card);
          return computedStyle.display !== 'none';
        });
        const hiddenCards = allCards.filter(card => {
          const computedStyle = window.getComputedStyle(card);
          return computedStyle.display === 'none';
        });

        if (sortValue === 'default') {
          // Restaurar orden original basado en data-book-index
          allCards.sort((a, b) => {
            const indexA = parseInt(a.getAttribute('data-book-index') || '0');
            const indexB = parseInt(b.getAttribute('data-book-index') || '0');
            return indexA - indexB;
          });
        } else {
          // Ordenar solo las tarjetas visibles
          visibleCards.sort((a, b) => {
            switch (sortValue) {
              case 'title-asc':
                const titleA = a.getAttribute('data-book-title') || '';
                const titleB = b.getAttribute('data-book-title') || '';
                return titleA.localeCompare(titleB, 'es', { sensitivity: 'base' });
              
              case 'title-desc':
                const titleADesc = a.getAttribute('data-book-title') || '';
                const titleBDesc = b.getAttribute('data-book-title') || '';
                return titleBDesc.localeCompare(titleADesc, 'es', { sensitivity: 'base' });
              
              case 'author-asc':
                const authorA = a.getAttribute('data-book-first-author') || '';
                const authorB = b.getAttribute('data-book-first-author') || '';
                return authorA.localeCompare(authorB, 'es', { sensitivity: 'base' });
              
              case 'author-desc':
                const authorADesc = a.getAttribute('data-book-first-author') || '';
                const authorBDesc = b.getAttribute('data-book-first-author') || '';
                return authorBDesc.localeCompare(authorADesc, 'es', { sensitivity: 'base' });
              
              case 'read-date-asc':
                const dateA = a.getAttribute('data-book-read-date') || '';
                const dateB = b.getAttribute('data-book-read-date') || '';
                if (!dateA && !dateB) return 0;
                if (!dateA) return 1; // Sin fecha al final
                if (!dateB) return -1;
                return dateA.localeCompare(dateB);
              
              case 'read-date-desc':
                const dateADesc = a.getAttribute('data-book-read-date') || '';
                const dateBDesc = b.getAttribute('data-book-read-date') || '';
                if (!dateADesc && !dateBDesc) return 0;
                if (!dateADesc) return 1; // Sin fecha al final
                if (!dateBDesc) return -1;
                return dateBDesc.localeCompare(dateADesc);
              
              default:
                return 0;
            }
          });
        }

        // Reordenar en el DOM: primero las visibles ordenadas, luego las ocultas
        visibleCards.forEach((card, index) => {
          // Remover clases stagger anteriores
          card.classList.remove('stagger-1', 'stagger-2', 'stagger-3', 'stagger-4', 'stagger-5', 'stagger-6', 'stagger-7', 'stagger-8');
          // Agregar clase stagger basada en el índice (máximo 8 para no exceder)
          const staggerIndex = (index % 8) + 1;
          card.classList.add(`stagger-${staggerIndex}`);
          bookGrid.appendChild(card);
        });
        hiddenCards.forEach(card => bookGrid.appendChild(card));
        
        // Aplicar animación de aparición después de un pequeño delay para que el DOM se actualice
        requestAnimationFrame(() => {
          visibleCards.forEach(card => {
            if (!card.classList.contains('showing')) {
              card.classList.add('showing');
              setTimeout(() => {
                card.classList.remove('showing');
              }, 400);
            }
          });
        });
      }

      // Event listeners
      searchInput.addEventListener('input', () => filterBooks('search'));
      statusFilter.addEventListener('change', () => filterBooks('status'));
      authorFilter.addEventListener('change', () => filterBooks('author'));
      publisherFilter.addEventListener('change', () => filterBooks('publisher'));
      sortSelect.addEventListener('change', function() {
        const sort = sortSelect.value;
        // Obtener otros parámetros actuales para mantenerlos en la URL
        const currentParams = getURLParams();
        updateURL({ 
          search: currentParams.search, 
          status: currentParams.status, 
          author: currentParams.author, 
          publisher: currentParams.publisher, 
          sort: sort 
        });
        sortBooks();
      });

      clearButton.addEventListener('click', function() {
        searchInput.value = '';
        statusFilter.value = 'all';
        authorFilter.value = 'all';
        publisherFilter.value = 'all';
        sortSelect.value = 'default';
        filterBooks(null);
      });

      // Cargar filtros desde URL al iniciar
      const params = getURLParams();
      searchInput.value = params.search;
      statusFilter.value = params.status;
      authorFilter.value = params.author;
      publisherFilter.value = params.publisher;
      sortSelect.value = params.sort;
      
      // Ejecutar filtrado después de un pequeño delay para asegurar que las tarjetas estén renderizadas
      // Primero actualizar dropdowns, luego filtrar
      setTimeout(() => {
        updateDropdowns(null);
        filterBooks(null);
      }, 300);
    }

    // Esperar a que el DOM esté completamente cargado
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initFilters);
    } else {
      // Si el DOM ya está listo, ejecutar después de un pequeño delay
      setTimeout(initFilters, 500);
    }
  })();
</script>

<style>
  .filter-bar {
    display: flex;
    flex-wrap: wrap;
    gap: 0.75rem;
    margin-bottom: 1.5rem;
    margin-top: 0;
    padding: 1rem;
    background-color: var(--bg);
    border: 1px solid var(--border);
    border-radius: 4px;
  }

  .filter-group {
    display: flex;
    flex-direction: column;
    gap: 0.375rem;
    flex: 1;
    min-width: 150px;
  }

  .filter-label {
    font-size: var(--font-size-s);
    font-weight: var(--font-weight-medium);
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  .filter-input,
  .filter-select {
    padding: 0.5rem 0.75rem;
    font-size: var(--font-size-m);
    font-family: var(--sans);
    color: var(--text-primary);
    background-color: var(--bg);
    border: 1px solid var(--border);
    border-radius: 2px;
    transition: border-color 0.2s ease-out;
    height: 2.5rem;
    box-sizing: border-box;
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
  }

  .filter-input:focus,
  .filter-select:focus {
    outline: 3px solid var(--text-primary);
    outline-offset: 2px;
    border-color: var(--text-primary);
  }

  .filter-input:focus-visible,
  .filter-select:focus-visible {
    outline: 3px solid var(--text-primary);
    outline-offset: 2px;
  }

  /* Asegurar que los selects tengan el mismo estilo */
  .filter-select {
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23000' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 0.75rem center;
    background-size: 12px;
    padding-right: 2.5rem;
  }

  .clear-button {
    padding: 0.5rem 1rem;
    font-size: var(--font-size-m);
    font-family: var(--sans);
    color: var(--text-primary);
    background-color: transparent;
    border: 1px solid var(--border);
    border-radius: 2px;
    cursor: pointer;
    transition: background-color 0.2s ease-out, border-color 0.2s ease-out;
    align-self: flex-end;
    white-space: nowrap;
    height: 2.5rem;
    box-sizing: border-box;
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
  }

  .clear-button:hover,
  .clear-button:focus {
    background-color: var(--selection);
    border-color: var(--text-primary);
  }

  .clear-button:focus-visible {
    outline: 2px solid var(--text-primary);
    outline-offset: 2px;
  }

  .filter-results {
    margin-bottom: 1.5rem;
    font-size: var(--font-size-s);
    color: var(--text-secondary);
  }

  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border-width: 0;
  }

  @media (max-width: 768px) {
    .filter-bar {
      flex-direction: column;
      padding: 0.75rem;
      gap: 0.5rem;
    }

    .filter-group {
      min-width: 100%;
      gap: 0.25rem;
    }

    .clear-button {
      align-self: stretch;
      width: 100%;
    }
  }

  @media (max-width: 480px) {
    .filter-bar {
      padding: 0.5rem;
      gap: 0.5rem;
    }

    .filter-group {
      gap: 0.25rem;
    }

    .filter-label {
      font-size: 0.75rem;
    }

    .filter-input,
    .filter-select,
    .clear-button {
      font-size: var(--font-size-s);
      padding: 0.4rem 0.6rem;
      height: 2.25rem;
    }
  }
</style>
