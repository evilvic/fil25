---
import type { Book } from '../types/book';

interface Props {
  books: Book[];
}

const { books } = Astro.props;

// Extraer valores únicos para los filtros
const allAuthors = [...new Set(books.flatMap(book => book.author))].sort();
const allPublishers = [...new Set(books.flatMap(book => book.publishers))].sort();
---

<div class="filter-bar" id="filter-bar">
  <div class="filter-group">
    <label for="search-input" class="filter-label">Buscar</label>
    <input
      type="text"
      id="search-input"
      class="filter-input"
      placeholder="Buscar por título..."
      autocomplete="off"
    />
  </div>

  <div class="filter-group">
    <label for="status-filter" class="filter-label">Estado</label>
    <select id="status-filter" class="filter-select">
      <option value="all">Todos</option>
      <option value="read">Leídos</option>
      <option value="unread">Pendientes</option>
    </select>
  </div>

  <div class="filter-group">
    <label for="author-filter" class="filter-label">Autor</label>
    <select id="author-filter" class="filter-select">
      <option value="all">Todos los autores</option>
      {allAuthors.map(author => (
        <option value={author}>{author}</option>
      ))}
    </select>
  </div>

  <div class="filter-group">
    <label for="publisher-filter" class="filter-label">Editorial</label>
    <select id="publisher-filter" class="filter-select">
      <option value="all">Todas las editoriales</option>
      {allPublishers.map(publisher => (
        <option value={publisher}>{publisher}</option>
      ))}
    </select>
  </div>

  <button id="clear-filters" class="clear-button" type="button">Limpiar filtros</button>
</div>

<div class="filter-results" id="filter-results">
  <span id="results-count"></span>
</div>

<script is:inline>
  (function() {
    'use strict';

    // Función para inicializar cuando el DOM esté listo
    function initFilters() {
      // Elementos del DOM
      const searchInput = document.getElementById('search-input');
      const statusFilter = document.getElementById('status-filter');
      const authorFilter = document.getElementById('author-filter');
      const publisherFilter = document.getElementById('publisher-filter');
      const clearButton = document.getElementById('clear-filters');
      const resultsCount = document.getElementById('results-count');

      if (!searchInput || !statusFilter || !authorFilter || !publisherFilter || !clearButton) {
        console.error('Elementos de filtro no encontrados');
        setTimeout(initFilters, 100);
        return;
      }

      // Función para actualizar la URL sin recargar
      function updateURL(params) {
        try {
          const url = new URL(window.location.href);
          Object.entries(params).forEach(([key, value]) => {
            if (value && value !== 'all') {
              url.searchParams.set(key, value);
            } else {
              url.searchParams.delete(key);
            }
          });
          window.history.replaceState({}, '', url);
        } catch (e) {
          console.error('Error actualizando URL:', e);
        }
      }

      // Función para leer parámetros de la URL
      function getURLParams() {
        try {
          const params = new URLSearchParams(window.location.search);
          return {
            search: params.get('search') || '',
            status: params.get('status') || 'all',
            author: params.get('author') || 'all',
            publisher: params.get('publisher') || 'all',
          };
        } catch (e) {
          return { search: '', status: 'all', author: 'all', publisher: 'all' };
        }
      }

      // Función para obtener libros que coinciden con filtros (excluyendo un filtro específico)
      function getMatchingBooks(excludeFilter) {
        const bookCards = document.querySelectorAll('.book-card');
        const searchTerm = excludeFilter !== 'search' ? searchInput.value.toLowerCase().trim() : '';
        const status = excludeFilter !== 'status' ? statusFilter.value : 'all';
        const author = excludeFilter !== 'author' ? authorFilter.value : 'all';
        const publisher = excludeFilter !== 'publisher' ? publisherFilter.value : 'all';

        const matchingBooks = [];

        bookCards.forEach((card) => {
          const cardTitle = card.getAttribute('data-book-title') || '';
          const cardSubtitle = card.getAttribute('data-book-subtitle') || '';
          const cardAuthors = JSON.parse(card.getAttribute('data-book-authors') || '[]');
          const cardPublishers = JSON.parse(card.getAttribute('data-book-publishers') || '[]');
          const cardRead = card.getAttribute('data-book-read') === 'true';

          const matchesSearch = !searchTerm || 
            cardTitle.includes(searchTerm) ||
            cardSubtitle.includes(searchTerm);
          const matchesStatus = status === 'all' ||
            (status === 'read' && cardRead) ||
            (status === 'unread' && !cardRead);
          const matchesAuthor = author === 'all' ||
            cardAuthors.includes(author);
          const matchesPublisher = publisher === 'all' ||
            cardPublishers.includes(publisher);

          if (matchesSearch && matchesStatus && matchesAuthor && matchesPublisher) {
            matchingBooks.push({
              authors: cardAuthors,
              publishers: cardPublishers
            });
          }
        });

        return matchingBooks;
      }

      // Función para actualizar opciones de un select
      function updateSelectOptions(selectElement, options, currentValue) {
        const isAuthorFilter = selectElement.id === 'author-filter';
        const defaultText = isAuthorFilter ? 'Todos los autores' : 'Todas las editoriales';
        
        // Guardar el valor actual antes de limpiar
        const previousValue = selectElement.value;
        
        // Limpiar y reconstruir opciones
        selectElement.innerHTML = '<option value="all">' + defaultText + '</option>';
        
        options.forEach(option => {
          const optionElement = document.createElement('option');
          optionElement.value = option;
          optionElement.textContent = option;
          selectElement.appendChild(optionElement);
        });

        // Mantener la selección actual si está disponible, o resetear a 'all'
        // Usar currentValue primero, luego previousValue como fallback
        const valueToUse = currentValue || previousValue;
        if (valueToUse && valueToUse !== 'all' && options.includes(valueToUse)) {
          selectElement.value = valueToUse;
        } else {
          selectElement.value = 'all';
        }
      }

      // Función para actualizar los dropdowns basándose en los filtros activos
      function updateDropdowns(changedFilter) {
        // Para autores: siempre excluir el filtro de autor para mostrar todas las opciones disponibles
        // Esto considera: search, status, y publisher (pero no author)
        const booksForAuthors = getMatchingBooks('author');
        const availableAuthors = [...new Set(booksForAuthors.flatMap(book => book.authors))].sort();

        // Para editoriales: siempre excluir el filtro de editorial para mostrar todas las opciones disponibles
        // Esto considera: search, status, y author (pero no publisher)
        const booksForPublishers = getMatchingBooks('publisher');
        const availablePublishers = [...new Set(booksForPublishers.flatMap(book => book.publishers))].sort();

        // Actualizar dropdown de autores (siempre, para reflejar los filtros actuales)
        const currentAuthor = authorFilter.value;
        updateSelectOptions(authorFilter, availableAuthors, currentAuthor);

        // Actualizar dropdown de editoriales (siempre, para reflejar los filtros actuales)
        const currentPublisher = publisherFilter.value;
        updateSelectOptions(publisherFilter, availablePublishers, currentPublisher);
      }

      // Función de filtrado
      function filterBooks(changedFilter) {
        // Obtener referencias a las tarjetas de libros (cada vez por si cambian)
        const bookCards = document.querySelectorAll('.book-card');
        
        if (bookCards.length === 0) {
          console.warn('No se encontraron tarjetas de libros, reintentando...');
          setTimeout(() => filterBooks(changedFilter), 100);
          return;
        }

        const searchTerm = searchInput.value.toLowerCase().trim();
        const status = statusFilter.value;
        const author = authorFilter.value;
        const publisher = publisherFilter.value;

        // Actualizar URL
        updateURL({ search: searchTerm, status, author, publisher });

        // Actualizar dropdowns dinámicamente ANTES de filtrar
        updateDropdowns(changedFilter);

        // Re-obtener valores después de actualizar dropdowns (por si se reseteó)
        const finalAuthor = authorFilter.value;
        const finalPublisher = publisherFilter.value;

        let visibleCount = 0;

        bookCards.forEach((card) => {
          // Leer datos directamente de los data attributes
          const cardTitle = card.getAttribute('data-book-title') || '';
          const cardSubtitle = card.getAttribute('data-book-subtitle') || '';
          const cardAuthors = JSON.parse(card.getAttribute('data-book-authors') || '[]');
          const cardPublishers = JSON.parse(card.getAttribute('data-book-publishers') || '[]');
          const cardRead = card.getAttribute('data-book-read') === 'true';

          // Filtro de búsqueda (título y subtítulo)
          const matchesSearch = !searchTerm || 
            cardTitle.includes(searchTerm) ||
            cardSubtitle.includes(searchTerm);

          // Filtro de estado
          const matchesStatus = status === 'all' ||
            (status === 'read' && cardRead) ||
            (status === 'unread' && !cardRead);

          // Filtro de autor
          const matchesAuthor = finalAuthor === 'all' ||
            cardAuthors.includes(finalAuthor);

          // Filtro de editorial
          const matchesPublisher = finalPublisher === 'all' ||
            cardPublishers.includes(finalPublisher);

          // Mostrar u ocultar según todos los filtros
          if (matchesSearch && matchesStatus && matchesAuthor && matchesPublisher) {
            card.style.display = '';
            visibleCount++;
          } else {
            card.style.display = 'none';
          }
        });

        // Actualizar contador de resultados
        if (resultsCount) {
          if (visibleCount === bookCards.length) {
            resultsCount.textContent = '';
          } else {
            resultsCount.textContent = `${visibleCount} de ${bookCards.length} libros`;
          }
        }
      }

      // Event listeners
      searchInput.addEventListener('input', () => filterBooks('search'));
      statusFilter.addEventListener('change', () => filterBooks('status'));
      authorFilter.addEventListener('change', () => filterBooks('author'));
      publisherFilter.addEventListener('change', () => filterBooks('publisher'));

      clearButton.addEventListener('click', function() {
        searchInput.value = '';
        statusFilter.value = 'all';
        authorFilter.value = 'all';
        publisherFilter.value = 'all';
        filterBooks(null);
      });

      // Cargar filtros desde URL al iniciar
      const params = getURLParams();
      searchInput.value = params.search;
      statusFilter.value = params.status;
      authorFilter.value = params.author;
      publisherFilter.value = params.publisher;
      
      // Ejecutar filtrado después de un pequeño delay para asegurar que las tarjetas estén renderizadas
      // Primero actualizar dropdowns, luego filtrar
      setTimeout(() => {
        updateDropdowns(null);
        filterBooks(null);
      }, 300);
    }

    // Esperar a que el DOM esté completamente cargado
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initFilters);
    } else {
      // Si el DOM ya está listo, ejecutar después de un pequeño delay
      setTimeout(initFilters, 500);
    }
  })();
</script>

<style>
  .filter-bar {
    display: flex;
    flex-wrap: wrap;
    gap: 0.75rem;
    margin-bottom: 1.5rem;
    margin-top: 0;
    padding: 1rem;
    background-color: var(--bg);
    border: 1px solid var(--border);
    border-radius: 4px;
  }

  .filter-group {
    display: flex;
    flex-direction: column;
    gap: 0.375rem;
    flex: 1;
    min-width: 150px;
  }

  .filter-label {
    font-size: var(--font-size-s);
    font-weight: var(--font-weight-medium);
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  .filter-input,
  .filter-select {
    padding: 0.5rem 0.75rem;
    font-size: var(--font-size-m);
    font-family: var(--sans);
    color: var(--text-primary);
    background-color: var(--bg);
    border: 1px solid var(--border);
    border-radius: 2px;
    transition: border-color 0.2s ease-out;
    height: 2.5rem;
    box-sizing: border-box;
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
  }

  .filter-input:focus,
  .filter-select:focus {
    outline: 2px solid var(--text-tertiary);
    outline-offset: 2px;
    border-color: var(--text-primary);
  }

  /* Asegurar que los selects tengan el mismo estilo */
  .filter-select {
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23000' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 0.75rem center;
    background-size: 12px;
    padding-right: 2.5rem;
  }

  .clear-button {
    padding: 0.5rem 1rem;
    font-size: var(--font-size-m);
    font-family: var(--sans);
    color: var(--text-primary);
    background-color: transparent;
    border: 1px solid var(--border);
    border-radius: 2px;
    cursor: pointer;
    transition: background-color 0.2s ease-out, border-color 0.2s ease-out;
    align-self: flex-end;
    white-space: nowrap;
    height: 2.5rem;
    box-sizing: border-box;
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
  }

  .clear-button:hover {
    background-color: var(--selection);
    border-color: var(--text-primary);
  }

  .filter-results {
    margin-bottom: 1.5rem;
    font-size: var(--font-size-s);
    color: var(--text-secondary);
  }

  @media (max-width: 768px) {
    .filter-bar {
      flex-direction: column;
      padding: 0.75rem;
      gap: 0.5rem;
    }

    .filter-group {
      min-width: 100%;
      gap: 0.25rem;
    }

    .clear-button {
      align-self: stretch;
      width: 100%;
    }
  }

  @media (max-width: 480px) {
    .filter-bar {
      padding: 0.5rem;
      gap: 0.5rem;
    }

    .filter-group {
      gap: 0.25rem;
    }

    .filter-label {
      font-size: 0.75rem;
    }

    .filter-input,
    .filter-select,
    .clear-button {
      font-size: var(--font-size-s);
      padding: 0.4rem 0.6rem;
      height: 2.25rem;
    }
  }
</style>
